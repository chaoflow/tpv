* Bits and Pieces
** tpv
*** event
starapi sends emails, if a user is approved. How can we solve this
more generic?

An event could have a name and be defined by a method call where the
parameters match regexes. An email is sent if an event "user-approved"
is triggered.

**** example user approval (model/user.py:39)
update(_next, self, attributes)

**** event types (or down to every possible method?!)
***** update
***** add
***** ...

**** we could/should use zope.event 
https://pypi.python.org/pypi/zope.event
http://docs.zope.org/zope.event/usage.html


**** implementation of event queue based on regexes

***** usage scenario
#+begin_src python
  import tpv.event
  
  # subscribing
  def send_email_on_user_status_change(userdata):
      # send email
      pass
  tpv.event.subscriber['user-.*'] = send_email_on_user_status_change
  
  # firing
  tpv.event.notify('user-approved', userdata)
#+end_src


***** queue and sorting
to be written to tpv.event
#+begin_src python
  import re
  
  subscriber = dict()
  
  def notify(evtype, evdata):
      for regex, func in tpv_subscriber:
          if re.match(regex, event.evtype):
              func(event.evdata)
#+end_src

***** possibly zope event redirection
#+begin_src python
  import zope.event

  class Event(object):
      def __init__(self, evtype, **evdata):
          self.evtype = evtype
          self.evdata = evdata

  def zope_subscriber(event):
      if not isinstance(event, TPVEvent):
          return

      notify(event.evtype, event.evdata)

  zope.event.subscribers.append(zope_subscriber)
#+end_src

firing then like

#+begin_src python
  import zope.event, tpv.event
  zope.event.notify(tpv.event.Event('user-apporoved', userdata))
#+end_src


***** subscription possibly using decorator syntax 
wish
#+begin_src python
  import tpv.event

  @tpv.event.subscribe(regex="user-.*")
  def send_email_on_user_status_change(userdata):
      # send email
#+end_src

implementation as aspect (does it work like this???)
#+begin_src python
  from metachao import aspect

  class subscribe(aspect.Aspect):
      regex = aspect.config(None)

      @aspect.plumb
      def __init__(_next, self):
          global subscriber
          subscriber[self.regex] = self
#+end_src

*** acl
How can we solve ACLs more generically?
check starapi/acl.py

we want declarative

maybe one acl aspect, that uses functions like
self_may_change_password.

*** generic aspects
**** think in dictionaries
**** what can be done by combining two or more parallel trees
***** use set operations to comine dicttrees
****** titanpad work
http://titanpad.com/PEWtchVWbS

Generic aspects:

A = {"a" : "Aabc", "b": { "b1": "Acde", "b2": "Afgh" }, "d": "Aijk" }
B = {"a" : "Babc", "b": { "b1": "Bcde", "b3": "Bfgh" }, "e": "Bijk" }

merge

C = {"a" : ["Aabc", "Babc"], "b" : { "b1": ["Acde", "Bcde"], "b2": "Afgh" , "b3": "Bfgh"}, "d": "Aijk" , "e": "Bijk"}


fallback

C = {"a" : "Aabc", "b": { "b1": "Acde", "b2": "Afgh", "b3": "Bfgh" }, "d": "Aijk", "e": "Bijk" }

C[b] -> weder A[b] noch B[b] -> fallback(A[b],B[b])

fallback(A, to=B)

class fallback (aspect.Aspect):
     to = aspect.config(to = null)

cache

siehe fallback + A übernimmt elem falls gefunden in B
A soll als config übergeben



XOR - elem aus A wenn elem nicht in B -> C[key] != null when (A[key] != null && B[key] == null) || (A[key] == null && B[key] != null), C[key] == null when A[key] != null && B[key] != null
intersectdata - attribute aus einem knoten in A ohne attrs aus dem knoten in B
intersect
xxx - f(x1. x2) = x1+x2

A rootnode of some dicttree
with attributes "a", "c"
and child "b" (with attributes "b1", "b2")


Daten
A[a] + B[c] 


For any set operation oper

A oper B -> C
so that set(A.keys() oper set(B.keys) == C.keys() and C[key] == f(A[key], B[key])
f(x1. x2) = x1 if x2 != null else x2

A&B -> C, C is dict
(A&B).keys() 

Returns Set
dictview & other
Return the intersection of the dictview and the other object as a new set.
A = {"a" : ["Aabc", "Babc", "Cabc"], "b": { "b1": "Acde", "b2": "Afgh" }, "d": "Aijk" }
B = {"a" : ["Aabc", "Cabc"], "b": { "b1": "Bcde", "b3": "Bfgh" }, "d": "Aijk" }

1. key ebene
A&B -> C = {"a" : ["Aabc", "Babc", "Cabc"], "d": "Aijk", "b": {"b1": "Acde"}} , { key: val for key, val in A.iteritems() if key in B }

2. value ebene
A&B -> C = {"a": ["Aabc", "Cabc"], "b": { }, "d": "Aijk" }

Annahme
B =  {"a" : ["Aabc", "Cabc"], "b": "b1aaaa", "d": "Aijk" }
A&B -> C = {"a": ["Aabc", "Cabc"], "d": "Aijk" }

{ key: set(A.get(key, [])) op set(B.get(key, [])) for key in A.keys() }


3. item ebene
siehe allg. items
A&B -> C = {"a": ["Aabc", "Cabc"], "b": { }, "d": "Aijk" }

Alternative 
3. item ebene ->
{ key: val for key, val in A.iteritems() if key in B and val == B[key] }


dictview | other
Return the union of the dictview and the other object as a new set.

1. keys 
siehe fallback

2. values
A = {"a" : "Aabc", "b": { "b1": "Acde", "b2": "Afgh" }, "d": "Aijk" }
B = {"a" : "Babc", "b": { "b1": "Bcde", "b3": "Bfgh" }, "e": "Bijk" }

C = {"a" : ["Aabc", "Babc"], "b" : { "b1": ["Acde", "Bcde"], "b2": "Afgh"}, "d": "Aijk"}

{ key: set(A.get(key, [])) op set(B.get(key, [])) for key in A.keys() }

3. items
siehe merge

{ key: set(A.get(key, [])) op set(B.get(key, [])) for key in set(A.keys()) op set(B.keys()) }

dictview - other
Return the difference between the dictview and the other object (all elements in dictview that aren’t in other) as a new set.

1. keys
siehe allg. keys

2. values 
siehe allg. values

3. items
siehe allg. items

dictview ^ other
Return the symmetric difference (all elements either in dictview or other, but not in both) of the dictview and the other object as a new set.

1. keys
siehe allg. keys

2. values
siehe allg. values

3. items
nicht zutreffend, da keys immer unterschiedlich, glech wie keys

set allgemein

1. keys
{ key: A.get(key, B.get(key))) for key in set(A.keys()) op set(B.keys())
if A.get(key, B.get(key))) }

2. values
{ key: set(A.get(key, [])) op set(B.get(key, [])) for key in A.keys() 
if set(A.get(key, [])) op set(B.get(key, [])) }

3. items
{ key: set(A.get(key, [])) op set(B.get(key, [])) for key in set(A.kegys()) op set(B.keys())
if set(A.get(key, [])) op set(B.get(key, [])) }


Zusätzlich
Finde alle keys aus B wenn werte mit elems aus A übereinstimmen
A = [("Aabc", "Cabc") , "Aijk", "Bcde" ]
B = {"a" : ["Aabc", "Cabc"], "b": { "b1": "Bcde", "b3": "Bfgh" }, "d": "Aijk", "e": "Aijk" }
C = {("Aabc", "Cabc") : "a", "Bcde": [["b", "b1"]], "Aijk": ["d", "e"]}



****** summary
set operations are applied recursively to one of three layers (keys,
values, items), where their definition on one dictionary is
approximately the following:

1. keys
{ key: A.get(key, B.get(key))) for key in set(A.keys()) op set(B.keys())
if A.get(key, B.get(key))) }

2. values
{ key: set(A.get(key, [])) op set(B.get(key, [])) for key in A.keys() 
if set(A.get(key, [])) op set(B.get(key, [])) }

3. items
{ key: set(A.get(key, [])) op set(B.get(key, [])) for key in set(A.kegys()) op set(B.keys())
if set(A.get(key, [])) op set(B.get(key, [])) }


****** derived aspects
fallback is a key layer with the union operation
merge is a item layer with the union operation

cache doesn't fall into these categories
***** cache
a prototype has been implemented in generic.py.

one tree is used to cache information in another tree.
****** check cache
****** return if cached
****** get value = _next(...)
****** write val into cache
****** return value
***** fallback
traverse one tree and fall back to other tree on KeyError.
****** check _next and return if successful
****** check fallback if not successful
***** merge
traverse two trees and merge the information to be returned
***** call first, hand second as argument
??
***** common problem
the aspect logic is often made complicated by having to deal with
unbalanced trees ... general solution ???

*** look through starapi
come up with ideas/code that generalizes the concepts being used in
there

** tpv.cli
metachao.classtree.node and plumbum.cli are used to created a tree of
commands and subcommands. A command is a class, a subcommand is a
child class. Instantiation is handled by plumbum.cli.

tpv.nix is using tpv.cli already. see there and plumbum.cli
documentation for what you can do.

*** tab completion for bash and zsh (zsh priority)
We have two trees: application model and data model, for both we want
tab completion. (Maybe it is just calling keys and filtering out the
ones with the already types prefix).

**** static (application model)
From plumbum.cli command tree we want tab completion for commands,
subcommands and their options.

Contact plumbum.cli author whether he has thoughts on how to achieve this.

**** dynamic (data model)
For dynamic lookups, I would imagine the shell to call a cli command
with a special parameter, e.g.:

mrsd clone /github/chaoflow/tpv<TAB>
--> mrsd clone --auto-complete github/chaoflow/tpv

In this case we would have a top-level command (mrsd) with a sublevel
command (clone) and a data model with a Github connector class as
direct child of the root classtree.Node. Traversing in, connects to
github in effect listing all repos starting with tpv.

** tpv.http
Provide a restful API to interact with tpv trees and connect restful
APIs as tpv subtrees.

local users.add(<data>) -> POST /users <data> -> remote: users.add(data)

A restful tpv application knows 4 commands: GET, POST, PUT, DELETE

First these are implemented as tpv.cli commands, then http request are
translated for the tpv.cli parser:

*** tpv.cli restful application
4 toplevel commands, check tpv.nix, for how commands are created and
nested

The __call__ methods contents is what
tpv.http.aspects.map_http_methods_to_model is currently doing.

All parameters that can be given via url query string shall be handled
via the cli parser, see below.
**** GET
**** POST
**** PUT
**** DELETE

*** map http request to cli
GET /foo/bar?foo&a=1&abc=2
--> GET --foo -a 1 --abc 2 /foo/bar

**** make this work for everything starapi needs

*** make GET /foo?help work
take message generated by plumbum.cli and render in pre tag. Don't
worry about -a and --abc being written there instead of ?a&abc

*** "mount" a remote tpv.http service as a subtree into a local tpv tree
